# 三级缓存架构说明

## 📋 概述

VabHub现在实现了**完整的三级缓存架构**，提供从最快到最持久的缓存层次。

**更新日期**: 2025-11-08  
**状态**: ✅ 三级缓存架构已实现

---

## 🏗️ 三级缓存架构

### L1: 内存缓存（Memory Cache）
- **速度**: ⚡⚡⚡ 最快（纳秒级）
- **容量**: 小（默认1000项）
- **持久化**: ❌ 服务重启后丢失
- **共享**: ❌ 仅当前进程可用
- **TTL**: 默认5分钟
- **用途**: 最热数据，频繁访问

### L2: Redis缓存（Redis Cache）
- **速度**: ⚡⚡ 快（毫秒级）
- **容量**: 中等（取决于Redis配置）
- **持久化**: ✅ 可配置（RDB/AOF）
- **共享**: ✅ 多进程/多服务共享
- **TTL**: 默认1小时
- **用途**: 热数据，跨进程共享

### L3: 数据库缓存（Database Cache）
- **速度**: ⚡ 较慢（10-50毫秒）
- **容量**: 大（取决于数据库容量）
- **持久化**: ✅ 完全持久化
- **共享**: ✅ 多进程/多服务共享
- **TTL**: 默认24小时
- **用途**: 冷数据，长期缓存，服务重启后仍可用

---

## 🔄 缓存工作流程

### 读取流程（L1 → L2 → L3）

```
1. 请求数据
   ↓
2. 检查L1内存缓存
   ├─ 命中 → 返回（最快）
   └─ 未命中 ↓
3. 检查L2 Redis缓存
   ├─ 命中 → 回填L1 → 返回（快）
   └─ 未命中 ↓
4. 检查L3数据库缓存
   ├─ 命中 → 回填L2和L1 → 返回（较慢）
   └─ 未命中 ↓
5. 从数据源获取
   ├─ 写入L3 → 写入L2 → 写入L1 → 返回
```

### 写入流程（同时写入三级）

```
1. 获取数据
   ↓
2. 同时写入L1、L2、L3
   ├─ L1: 内存缓存（最快访问）
   ├─ L2: Redis缓存（共享访问）
   └─ L3: 数据库缓存（持久化）
```

---

## 📊 三级缓存对比

| 特性 | L1内存 | L2 Redis | L3数据库 |
|------|--------|----------|----------|
| **速度** | 最快（纳秒） | 快（毫秒） | 较慢（10-50ms） |
| **容量** | 小（1K项） | 中等 | 大（TB级） |
| **持久化** | ❌ | ✅ 可选 | ✅ 完全 |
| **共享** | ❌ | ✅ | ✅ |
| **成本** | 低 | 中 | 低 |
| **适用场景** | 最热数据 | 热数据 | 冷数据/长期缓存 |

---

## 🎯 为什么需要三级缓存？

### 1. 性能优化
- **L1内存**: 最热数据，访问最快
- **L2 Redis**: 热数据，跨进程共享
- **L3数据库**: 冷数据，持久化存储

### 2. 成本优化
- **L1内存**: 免费（使用应用内存）
- **L2 Redis**: 需要Redis服务器（可接受成本）
- **L3数据库**: 使用现有数据库（无额外成本）

### 3. 可靠性
- **L1内存**: 服务重启后丢失
- **L2 Redis**: Redis重启后可能丢失
- **L3数据库**: 完全持久化，服务重启后仍可用

### 4. 容量管理
- **L1内存**: 容量有限，只能存储最热数据
- **L2 Redis**: 容量中等，存储热数据
- **L3数据库**: 容量大，存储大量缓存数据

---

## 🔧 实现细节

### L3数据库缓存表结构

```sql
CREATE TABLE cache_entries (
    id INTEGER PRIMARY KEY,
    key VARCHAR(500) UNIQUE NOT NULL,
    value TEXT NOT NULL,
    ttl INTEGER NOT NULL DEFAULT 3600,
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL,
    expires_at DATETIME NOT NULL,
    INDEX idx_cache_key (key),
    INDEX idx_cache_expires_at (expires_at)
)
```

### 缓存键处理
- **普通键**: 直接使用（最大500字符）
- **长键**: 自动使用MD5哈希（`hash:{md5}`）

### 过期清理
- **自动清理**: 查询时自动检查过期
- **手动清理**: 支持批量清理过期缓存
- **定时清理**: 可配置定时任务清理

---

## 📈 性能提升

### 缓存命中率
- **L1命中**: 预期50-70%（最热数据）
- **L2命中**: 预期20-30%（热数据）
- **L3命中**: 预期5-10%（冷数据）
- **总命中率**: 预期75-90%

### 响应时间
- **L1命中**: < 1ms
- **L2命中**: 1-5ms
- **L3命中**: 10-50ms
- **未命中**: 100-1000ms（取决于数据源）

---

## 🎯 使用场景

### 适合L1内存缓存
- 频繁访问的配置数据
- 用户会话数据
- 实时统计数据

### 适合L2 Redis缓存
- 跨进程共享的数据
- 需要分布式锁的数据
- 临时会话数据

### 适合L3数据库缓存
- 长期稳定的数据
- 服务重启后需要保留的数据
- 大量历史数据

---

## 🔍 实际应用示例

### Media API缓存
```python
# 搜索缓存：L1(5分钟) → L2(1小时) → L3(24小时)
cache_key = cache.generate_key("tmdb_search_movie", query=query)
await cache.set(cache_key, results, ttl=3600)  # 同时写入三级
```

### Music Service缓存
```python
# 搜索结果：L1(5分钟) → L2(30分钟) → L3(24小时)
cache_key = cache.generate_key("music_search", query=query)
await cache.set(cache_key, results, ttl=1800)  # 同时写入三级
```

### Dashboard Service缓存
```python
# 仪表盘数据：L1(5分钟) → L2(30秒) → L3(不缓存，数据变化频繁)
cache_key = cache.generate_key("dashboard_data")
await cache.set(cache_key, data, ttl=30)  # 主要使用L1和L2
```

---

## 💡 配置建议

### 开发环境
- **L1**: 启用（1000项）
- **L2**: 可选（Redis可选）
- **L3**: 启用（数据库缓存）

### 生产环境
- **L1**: 启用（5000-10000项）
- **L2**: 启用（Redis必需）
- **L3**: 启用（数据库缓存）

---

## 🧹 维护操作

### 清理过期缓存
```python
from app.core.cache import get_cache

cache = get_cache()
cleaned_count = await cache.cleanup_expired()
print(f"清理了 {cleaned_count} 个过期缓存")
```

### 清空所有缓存
```python
await cache.clear()  # 清空所有三级缓存
```

### 检查缓存状态
```bash
# 健康检查
GET /api/v1/health/cache
GET /api/v1/health/cache_l3
```

---

## ✅ 总结

三级缓存架构的优势：

1. **性能**: 多级缓存，最快访问速度
2. **容量**: 三级缓存，存储大量数据
3. **可靠性**: L3持久化，服务重启后仍可用
4. **成本**: 合理使用各级缓存，降低成本
5. **灵活性**: 可根据需求启用/禁用各级缓存

---

**最后更新**: 2025-11-08  
**状态**: ✅ 三级缓存架构已实现

