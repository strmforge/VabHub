# 115网盘API整合到主系统方案

## 📋 整合目标

将STRM系统中实现的115官方开发者API（`Cloud115API`）整合到主系统的`Cloud115Provider`中，消除代码重复，统一API调用方式。

## 🔧 整合方案

### 方案：重构Cloud115Provider使用Cloud115API（推荐）

**核心思路**：
- `Cloud115Provider`作为适配器层，实现`CloudStorageProvider`接口
- 内部使用`Cloud115API`、`Cloud115OAuth`、`Cloud115UploadManager`处理所有API调用
- 保持`CloudStorageProvider`接口不变，确保向后兼容

## 📝 实施步骤

### 步骤1：修改Cloud115Provider初始化

```python
# cloud_115.py
from .cloud_115_api import Cloud115API
from .cloud_115_oauth import Cloud115OAuth
from .cloud_115_upload import Cloud115UploadManager

class Cloud115Provider(CloudStorageProvider):
    def __init__(self):
        # ... 现有初始化代码 ...
        
        # 新增：API客户端
        self._api_client: Optional[Cloud115API] = None
        self._oauth_client: Optional[Cloud115OAuth] = None
        self._upload_manager: Optional[Cloud115UploadManager] = None
    
    async def _get_api_client(self) -> Optional[Cloud115API]:
        """获取Cloud115API客户端"""
        if not self.access_token:
            return None
        if not self._api_client:
            self._api_client = Cloud115API(access_token=self.access_token)
        return self._api_client
```

### 步骤2：重构OAuth2认证方法

```python
async def generate_qr_code(self) -> Tuple[str, str]:
    """生成二维码（使用Cloud115OAuth）"""
    if not self._oauth_client:
        self._oauth_client = Cloud115OAuth(
            app_id=self.app_id,
            passport_url=self.passport_url,
            qrcode_url=self.qrcode_url
        )
    return await self._oauth_client.generate_qr_code()

async def check_qr_status(self) -> Tuple[int, str, Dict[str, Any]]:
    """检查二维码状态（使用Cloud115OAuth）"""
    if not self._oauth_client:
        return -1, "请先生成二维码", {}
    return await self._oauth_client.check_qr_status()
```

### 步骤3：重构文件操作方法

```python
async def list_files(self, path: str = "/", recursive: bool = False) -> List[CloudFileInfo]:
    """列出文件（使用Cloud115API）"""
    api_client = await self._get_api_client()
    if not api_client:
        return []
    
    # 使用Cloud115API的list_files方法
    result = await api_client.list_files(path=path, limit=1000, offset=0)
    
    if not result.get("success"):
        return []
    
    # 转换为CloudFileInfo
    files = []
    for item in result.get("data", {}).get("list", []):
        files.append(self._convert_to_cloud_file_info(item, path))
    
    return files

def _convert_to_cloud_file_info(self, item: Dict, parent_path: str) -> CloudFileInfo:
    """将115 API响应转换为CloudFileInfo"""
    return CloudFileInfo(
        id=str(item.get("file_id", "")),
        name=item.get("file_name", ""),
        path=f"{parent_path.rstrip('/')}/{item.get('file_name', '')}",
        size=item.get("size_byte", 0) if item.get("file_category") == "1" else 0,
        type="file" if item.get("file_category") == "1" else "dir",
        parent_id=str(item.get("parent_id", "")),
        created_at=datetime.fromtimestamp(item.get("ptime", 0)) if item.get("ptime") else None,
        modified_at=datetime.fromtimestamp(item.get("utime", 0)) if item.get("utime") else None,
        metadata={
            "sha1": item.get("sha1"),
            "pick_code": item.get("pick_code"),
            "icon": item.get("ico")
        }
    )
```

### 步骤4：重构文件上传方法

```python
async def upload_file(
    self, 
    local_path: str, 
    remote_path: str, 
    progress_callback: Optional[callable] = None
) -> bool:
    """上传文件（使用Cloud115UploadManager）"""
    api_client = await self._get_api_client()
    if not api_client:
        return False
    
    if not self._upload_manager:
        self._upload_manager = Cloud115UploadManager(api_client)
    
    # 解析远程路径
    remote_path_obj = Path(remote_path)
    target_name = remote_path_obj.name
    target_dir_path = str(remote_path_obj.parent)
    
    # 获取目标目录ID
    folder_info = await api_client.get_file_info(path=target_dir_path)
    if not folder_info.get("success"):
        return False
    
    target_parent_id = folder_info["data"]["file_id"]
    
    # 上传文件
    result = await self._upload_manager.upload_file(
        local_path=local_path,
        target_parent_id=target_parent_id,
        file_name=target_name,
        progress_callback=progress_callback
    )
    
    return result.get("success", False)
```

### 步骤5：重构其他文件操作方法

```python
async def get_file_info(self, file_id: str) -> Optional[CloudFileInfo]:
    """获取文件信息（使用Cloud115API）"""
    api_client = await self._get_api_client()
    if not api_client:
        return None
    
    result = await api_client.get_file_info(file_id=file_id)
    if not result.get("success"):
        return None
    
    return self._convert_to_cloud_file_info(result["data"], "")

async def create_folder(self, parent_path: str, name: str) -> Optional[CloudFileInfo]:
    """创建文件夹（使用Cloud115API）"""
    api_client = await self._get_api_client()
    if not api_client:
        return None
    
    # 获取父目录ID
    parent_info = await api_client.get_file_info(path=parent_path)
    if not parent_info.get("success"):
        return None
    
    parent_id = parent_info["data"]["file_id"]
    
    # 创建文件夹
    result = await api_client.create_folder(pid=parent_id, file_name=name)
    if not result.get("success"):
        return None
    
    folder_data = result["data"]
    return CloudFileInfo(
        id=str(folder_data.get("file_id", "")),
        name=name,
        path=f"{parent_path.rstrip('/')}/{name}/",
        type="dir",
        parent_id=str(parent_id),
        created_at=datetime.now(),
        modified_at=datetime.now()
    )

async def delete_file(self, file_id: str) -> bool:
    """删除文件（使用Cloud115API）"""
    api_client = await self._get_api_client()
    if not api_client:
        return False
    
    result = await api_client.delete_file(file_ids=file_id)
    return result.get("success", False)

async def move_file(self, file_id: str, target_path: str, new_name: Optional[str] = None) -> bool:
    """移动文件（使用Cloud115API）"""
    api_client = await self._get_api_client()
    if not api_client:
        return False
    
    # 获取目标目录ID
    target_info = await api_client.get_file_info(path=target_path)
    if not target_info.get("success"):
        return False
    
    target_id = target_info["data"]["file_id"]
    
    # 移动文件
    result = await api_client.move_file(file_ids=file_id, to_cid=target_id)
    if not result.get("success"):
        return False
    
    # 如果需要重命名
    if new_name:
        result = await api_client.update_file(file_id=file_id, new_name=new_name)
        return result.get("success", False)
    
    return True

async def copy_file(
    self, 
    file_id: str, 
    target_path: str, 
    new_name: Optional[str] = None,
    recursive: bool = False
) -> bool:
    """复制文件（使用Cloud115API）"""
    api_client = await self._get_api_client()
    if not api_client:
        return False
    
    # 获取目标目录ID
    target_info = await api_client.get_file_info(path=target_path)
    if not target_info.get("success"):
        return False
    
    target_id = target_info["data"]["file_id"]
    
    # 复制文件
    result = await api_client.copy_file(file_id=file_id, pid=target_id)
    if not result.get("success"):
        return False
    
    # 如果需要重命名
    if new_name:
        # 获取新文件ID（需要延迟获取）
        await asyncio.sleep(2)
        # TODO: 实现重命名逻辑
        pass
    
    return True

async def rename_file(self, file_id: str, new_name: str) -> bool:
    """重命名文件（使用Cloud115API）"""
    api_client = await self._get_api_client()
    if not api_client:
        return False
    
    result = await api_client.update_file(file_id=file_id, new_name=new_name)
    return result.get("success", False)

async def download_file(
    self, 
    file_id: str, 
    save_path: str, 
    progress_callback: Optional[callable] = None,
    cancel_event: Optional[asyncio.Event] = None
) -> bool:
    """下载文件（使用Cloud115API）"""
    api_client = await self._get_api_client()
    if not api_client:
        return False
    
    # 获取文件信息
    file_info = await self.get_file_info(file_id)
    if not file_info:
        return False
    
    # 获取下载链接
    pick_code = file_info.metadata.get("pick_code")
    if not pick_code:
        return False
    
    result = await api_client.get_download_url(pick_code=pick_code)
    if not result.get("success"):
        return False
    
    download_url = result.get("download_url")
    if not download_url:
        return False
    
    # 下载文件
    # TODO: 实现下载逻辑（使用httpx或aiohttp）
    return True

async def get_storage_usage(self) -> Optional[CloudStorageUsage]:
    """获取存储使用情况（使用Cloud115API）"""
    api_client = await self._get_api_client()
    if not api_client:
        return None
    
    result = await api_client.get_user_info()
    if not result.get("success"):
        return None
    
    user_data = result["data"]
    space_info = user_data.get("rt_space_info", {})
    total = space_info.get("all_total", {}).get("size", 0)
    used = space_info.get("all_used", {}).get("size", 0)
    available = space_info.get("all_remain", {}).get("size", 0)
    
    percentage = (used / total * 100) if total > 0 else 0.0
    
    return CloudStorageUsage(
        total=total,
        used=used,
        available=available,
        percentage=percentage
    )
```

## ✅ 整合优势

1. **代码统一**：所有115 API调用都使用同一个客户端
2. **功能完整**：利用新API客户端的完整功能
3. **维护简单**：只需要维护一套API实现
4. **向后兼容**：`CloudStorageProvider`接口不变，主系统无需修改
5. **功能增强**：自动获得新API客户端的所有功能（如视频字幕列表等）

## ⚠️ 注意事项

1. **接口转换**：需要将`Cloud115API`的响应转换为`CloudFileInfo`
2. **错误处理**：统一错误处理方式
3. **测试**：确保整合后功能正常
4. **向后兼容**：确保现有功能不受影响
5. **Token管理**：确保token刷新机制正常工作

## 📚 参考文档

- `VabHub/115网盘官方API文档集成完成总结.md`
- `VabHub/115网盘API完整功能集成总结.md`
- `VabHub/STRM系统认证集成完成总结.md`
- `VabHub/115网盘API整合情况分析.md`

