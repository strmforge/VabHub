# 文件整理：事件驱动 vs 定时扫描方案对比

## 📋 用户提出的方案

**事件驱动方案**：
1. 在下载管理页面监控带标签的下载任务
2. 当任务完成时，任务从监控中消失（状态变为completed）
3. 此时系统立即通知开始整理
4. 而不是每5分钟扫描一次

## 🔄 两种方案对比

### 方案1：定时扫描（当前实现）

**实现方式**：
- 定时任务每5分钟扫描一次下载器
- 查询所有打了标签的已完成任务
- 逐个处理并整理

**优点**：
- ✅ 实现简单，逻辑清晰
- ✅ 不依赖下载器状态更新机制
- ✅ 有兜底机制，即使状态更新失败也能处理

**缺点**：
- ❌ 响应延迟（最多5分钟）
- ❌ 资源浪费（定时扫描所有下载器）
- ❌ 效率低（可能扫描到已经处理过的任务）

### 方案2：事件驱动（用户建议）

**实现方式**：
- 在下载任务状态更新时检测完成状态
- 如果任务完成且打了标签，立即触发整理
- 通过WebSocket或事件系统通知前端

**优点**：
- ✅ **实时响应**（任务完成立即处理）
- ✅ **节省资源**（不需要定时扫描）
- ✅ **高效**（只在任务完成时处理）
- ✅ **用户体验好**（前端可以实时显示整理进度）

**缺点**：
- ⚠️ 依赖下载器状态更新机制
- ⚠️ 如果状态更新失败，需要兜底机制
- ⚠️ 需要处理并发情况（多个任务同时完成）

## 🎯 推荐方案：混合模式

**最佳实践**：事件驱动 + 定时扫描兜底

### 主流程：事件驱动
1. 下载任务状态更新时检测完成状态
2. 如果任务完成且打了标签，立即触发整理
3. 通过WebSocket通知前端

### 兜底机制：定时扫描
1. 每30分钟（或更长）扫描一次
2. 处理可能遗漏的任务
3. 确保所有任务都被处理

## 📊 详细对比

| 维度 | 定时扫描（5分钟） | 事件驱动 | 混合模式（推荐） |
|------|-----------------|---------|----------------|
| **响应速度** | 最多5分钟延迟 | 实时（秒级） | 实时（秒级） |
| **资源占用** | 高（定时扫描） | 低（事件触发） | 低（事件+兜底） |
| **可靠性** | 高（有兜底） | 中（依赖状态更新） | 高（双重保障） |
| **实现复杂度** | 低 | 中 | 中高 |
| **用户体验** | 一般 | 优秀 | 优秀 |
| **系统负载** | 较高 | 低 | 低 |

## 💡 实现建议

### 1. 事件驱动实现

**在下载任务状态更新时触发**：

```python
# app/modules/download/service.py
async def update_download_status(self, task_id: str, status: str, **kwargs):
    """更新下载任务状态"""
    # 更新数据库状态
    task.status = status
    await self.db.commit()
    
    # 如果任务完成且打了标签，立即触发整理
    if status == "completed":
        # 检查是否有标签
        if await self._has_vabhub_tag(task):
            # 立即触发整理（异步，不阻塞）
            asyncio.create_task(self._trigger_transfer(task))
    
    # 通过WebSocket通知前端
    await manager.broadcast_download_update({
        "id": task.task_id,
        "status": status,
        ...
    })
```

### 2. 混合模式实现

**主流程：事件驱动**
```python
# 在状态更新时立即处理
if status == "completed" and has_tag:
    await transfer_service.transfer_directory(...)
```

**兜底机制：定时扫描（30分钟）**
```python
# 每30分钟扫描一次，处理遗漏的任务
@schedule_task(interval=1800)  # 30分钟
async def transfer_fallback():
    await downloader_monitor.process_completed_torrents()
```

### 3. 前端实时显示

**WebSocket通知**：
```javascript
// 前端接收整理通知
websocket.on('transfer_started', (data) => {
  // 显示整理进度
  showTransferProgress(data.task_id, data.file_path)
})

websocket.on('transfer_completed', (data) => {
  // 显示整理完成
  showTransferComplete(data.task_id, data.result)
})
```

## 🎯 最终推荐

**采用混合模式**：
1. **主流程**：事件驱动（任务完成立即整理）
2. **兜底机制**：定时扫描（每30分钟，处理遗漏任务）
3. **前端通知**：WebSocket实时推送整理进度

**优势**：
- ✅ 实时响应（用户体验好）
- ✅ 节省资源（不需要频繁扫描）
- ✅ 高可靠性（双重保障）
- ✅ 前端可以实时显示整理进度

## 📝 实现步骤

1. **修改下载服务**：在状态更新时检测完成状态并触发整理
2. **修改下载器监控**：改为兜底机制（30分钟扫描一次）
3. **添加WebSocket通知**：实时推送整理进度
4. **前端界面**：显示整理进度和状态

## ✨ 总结

用户提出的**事件驱动方案**非常优秀，比定时扫描更高效、更快速、更节省资源。建议采用**混合模式**（事件驱动 + 定时扫描兜底），既保证了实时响应，又确保了可靠性。

