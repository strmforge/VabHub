# VabHub 架构改进实施计划

## 📋 概述

基于 MoviePilot 深度分析结果，制定 VabHub 架构改进实施计划。

### 当前状态
- ✅ 功能完成度: 98%
- ✅ 核心功能: 全部完成
- ⚠️ 架构模式: 直接 API -> Service 模式（需要优化）
- ⚠️ Chain 模式: 未实现
- ✅ 存储抽象: 已有基础实现（需要优化）

### 改进目标
1. **引入 Chain 模式**: 统一处理不同模块的调用
2. **优化存储抽象**: 统一存储接口，支持多种存储后端
3. **改进115网盘集成**: 使用PKCE认证和OSS上传
4. **优化前后端关联**: 清晰的前后端API端点映射

---

## 阶段1: 引入 Chain 模式架构（优先级：高）

### 目标
创建 Chain 模式架构，统一处理不同模块的调用，提高代码的可维护性和可扩展性。

### 实施步骤

#### 1.1 创建 Chain 基类 (1天)

**文件**: `backend/app/chain/base.py`

```python
"""
Chain 基类
提供统一的处理链接口
"""

from abc import ABC, abstractmethod
from typing import Any, Optional, Dict
from loguru import logger


class ChainBase(ABC):
    """Chain 基类"""
    
    def __init__(self):
        self._cache = {}
        logger.debug(f"{self.__class__.__name__} 初始化")
    
    @abstractmethod
    async def process(self, *args, **kwargs) -> Any:
        """处理请求"""
        pass
    
    def _get_cache_key(self, *args, **kwargs) -> str:
        """生成缓存键"""
        import hashlib
        import json
        key_data = {
            "class": self.__class__.__name__,
            "args": str(args),
            "kwargs": json.dumps(kwargs, sort_keys=True)
        }
        key_str = json.dumps(key_data, sort_keys=True)
        return hashlib.md5(key_str.encode()).hexdigest()
    
    async def _get_from_cache(self, key: str) -> Optional[Any]:
        """从缓存获取"""
        return self._cache.get(key)
    
    async def _set_to_cache(self, key: str, value: Any, ttl: int = 3600):
        """设置缓存"""
        self._cache[key] = value
```

#### 1.2 实现 StorageChain (2天)

**文件**: `backend/app/chain/storage.py`

```python
"""
存储处理链
统一处理存储相关操作
"""

from typing import List, Optional, Dict, Any
from app.chain.base import ChainBase
from app.schemas.storage import FileItem
from loguru import logger


class StorageChain(ChainBase):
    """存储处理链"""
    
    def __init__(self):
        super().__init__()
        self._storages = {}
    
    async def process(self, operation: str, storage_id: int, *args, **kwargs) -> Any:
        """处理存储操作"""
        storage = await self._get_storage(storage_id)
        if not storage:
            raise ValueError(f"存储 {storage_id} 不存在")
        
        method = getattr(storage, operation, None)
        if not method:
            raise ValueError(f"存储 {storage_id} 不支持操作 {operation}")
        
        return await method(*args, **kwargs)
    
    async def list_files(self, storage_id: int, path: str = "/") -> List[FileItem]:
        """列出文件"""
        return await self.process("list_files", storage_id, path)
    
    async def delete_file(self, storage_id: int, path: str) -> bool:
        """删除文件"""
        return await self.process("delete_file", storage_id, path)
    
    async def mkdir(self, storage_id: int, path: str, name: str) -> bool:
        """创建目录"""
        return await self.process("mkdir", storage_id, path, name)
    
    async def _get_storage(self, storage_id: int):
        """获取存储实例"""
        if storage_id not in self._storages:
            from app.modules.cloud_storage.service import CloudStorageService
            from app.core.database import AsyncSessionLocal
            
            async with AsyncSessionLocal() as session:
                service = CloudStorageService(session)
                storage_config = await service.get_storage(storage_id)
                if not storage_config:
                    return None
                
                # 根据存储类型创建对应的存储实例
                if storage_config.provider == "115":
                    from app.chain.modules.u115 import U115Pan
                    self._storages[storage_id] = U115Pan(storage_config)
                elif storage_config.provider == "rclone":
                    from app.chain.modules.rclone import RCloneStorage
                    self._storages[storage_id] = RCloneStorage(storage_config)
                elif storage_config.provider == "openlist":
                    from app.chain.modules.openlist import OpenListStorage
                    self._storages[storage_id] = OpenListStorage(storage_config)
        
        return self._storages.get(storage_id)
```

#### 1.3 实现 SubscribeChain (2天)

**文件**: `backend/app/chain/subscribe.py`

```python
"""
订阅处理链
统一处理订阅相关操作
"""

from typing import List, Optional, Dict, Any
from app.chain.base import ChainBase
from app.schemas.subscription import Subscribe
from loguru import logger


class SubscribeChain(ChainBase):
    """订阅处理链"""
    
    def __init__(self):
        super().__init__()
    
    async def process(self, operation: str, *args, **kwargs) -> Any:
        """处理订阅操作"""
        from app.modules.subscription.service import SubscriptionService
        from app.core.database import AsyncSessionLocal
        
        async with AsyncSessionLocal() as session:
            service = SubscriptionService(session)
            method = getattr(service, operation, None)
            if not method:
                raise ValueError(f"订阅服务不支持操作 {operation}")
            
            return await method(*args, **kwargs)
    
    async def add(self, subscribe_data: Dict[str, Any]) -> tuple[int, str]:
        """添加订阅"""
        result = await self.process("create_subscription", subscribe_data)
        return result.get("id"), "订阅添加成功"
    
    async def update(self, subscribe_id: int, subscribe_data: Dict[str, Any]) -> bool:
        """更新订阅"""
        result = await self.process("update_subscription", subscribe_id, subscribe_data)
        return result.get("success", False)
    
    async def delete(self, subscribe_id: int) -> bool:
        """删除订阅"""
        result = await self.process("delete_subscription", subscribe_id)
        return result.get("success", False)
    
    async def list(self, filters: Optional[Dict[str, Any]] = None) -> List[Subscribe]:
        """列出订阅"""
        return await self.process("list_subscriptions", filters)
```

#### 1.4 实现 DownloadChain (2天)

**文件**: `backend/app/chain/download.py`

```python
"""
下载处理链
统一处理下载相关操作
"""

from typing import List, Optional, Dict, Any
from app.chain.base import ChainBase
from loguru import logger


class DownloadChain(ChainBase):
    """下载处理链"""
    
    def __init__(self):
        super().__init__()
    
    async def process(self, operation: str, *args, **kwargs) -> Any:
        """处理下载操作"""
        from app.modules.download.service import DownloadService
        from app.core.database import AsyncSessionLocal
        
        async with AsyncSessionLocal() as session:
            service = DownloadService(session)
            method = getattr(service, operation, None)
            if not method:
                raise ValueError(f"下载服务不支持操作 {operation}")
            
            return await method(*args, **kwargs)
    
    async def add(self, download_data: Dict[str, Any]) -> Dict[str, Any]:
        """添加下载任务"""
        return await self.process("create_download", download_data)
    
    async def pause(self, download_id: str) -> bool:
        """暂停下载"""
        return await self.process("pause_download", download_id)
    
    async def resume(self, download_id: str) -> bool:
        """恢复下载"""
        return await self.process("resume_download", download_id)
    
    async def delete(self, download_id: str) -> bool:
        """删除下载"""
        return await self.process("delete_download", download_id)
    
    async def list(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """列出下载任务"""
        return await self.process("list_downloads", filters)
```

#### 1.5 迁移现有代码 (3天)

**步骤**:
1. 更新 API 端点使用 Chain 模式
2. 保持向后兼容
3. 逐步迁移现有代码

**示例**:
```python
# backend/app/api/cloud_storage.py
@router.get("/{storage_id}/files", response_model=List[FileItem])
async def list_files(
    storage_id: int,
    path: str = "/",
    db: AsyncSession = Depends(get_db)
):
    """列出文件"""
    chain = StorageChain()
    files = await chain.list_files(storage_id, path)
    return files
```

#### 1.6 测试验证 (1天)

**测试内容**:
- Chain 模式基本功能测试
- 存储操作测试
- 订阅操作测试
- 下载操作测试
- 性能测试

---

## 阶段2: 优化存储抽象层（优先级：高）

### 目标
统一存储接口，支持多种存储后端，提高代码的可维护性和可扩展性。

### 实施步骤

#### 2.1 定义 StorageBase 接口 (1天)

**文件**: `backend/app/chain/modules/base.py`

```python
"""
存储基础类
定义统一的存储接口
"""

from abc import ABC, abstractmethod
from typing import List, Optional
from app.schemas.storage import FileItem


class StorageBase(ABC):
    """存储基础类"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.provider = config.get("provider", "unknown")
    
    @abstractmethod
    async def list_files(self, path: str) -> List[FileItem]:
        """列出文件"""
        pass
    
    @abstractmethod
    async def delete_file(self, path: str) -> bool:
        """删除文件"""
        pass
    
    @abstractmethod
    async def mkdir(self, path: str, name: str) -> bool:
        """创建目录"""
        pass
    
    @abstractmethod
    async def upload_file(self, local_path: str, remote_path: str) -> bool:
        """上传文件"""
        pass
    
    @abstractmethod
    async def download_file(self, remote_path: str, local_path: str) -> bool:
        """下载文件"""
        pass
    
    @abstractmethod
    async def get_usage(self) -> Dict[str, Any]:
        """获取存储使用情况"""
        pass
    
    async def close(self):
        """关闭连接"""
        pass
```

#### 2.2 实现存储后端 (4天)

**文件结构**:
```
backend/app/chain/modules/
├── __init__.py
├── base.py
├── u115.py      # 115网盘
├── rclone.py    # RClone
└── openlist.py  # OpenList
```

**115网盘实现** (`u115.py`):
```python
"""
115网盘存储实现
"""

from typing import List, Dict, Any
from app.chain.modules.base import StorageBase
from app.schemas.storage import FileItem
from loguru import logger


class U115Pan(StorageBase):
    """115网盘存储"""
    
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        self.client = None
        self._init_client()
    
    def _init_client(self):
        """初始化客户端"""
        # 使用现有的115客户端实现
        from app.modules.cloud_storage.providers.u115 import U115Provider
        self.client = U115Provider(self.config)
    
    async def list_files(self, path: str) -> List[FileItem]:
        """列出文件"""
        return await self.client.list_files(path)
    
    async def delete_file(self, path: str) -> bool:
        """删除文件"""
        return await self.client.delete_file(path)
    
    # ... 其他方法实现
```

#### 2.3 统一数据模型 (1天)

**文件**: `backend/app/schemas/storage.py`

```python
"""
存储相关数据模型
"""

from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime


class FileItem(BaseModel):
    """文件项"""
    name: str
    path: str
    type: str  # dir, file
    size: Optional[int] = None
    modify_time: Optional[datetime] = None
    extension: Optional[str] = None
    fileid: Optional[str] = None  # 115网盘文件ID
    storage: Optional[str] = None  # 存储类型
```

#### 2.4 测试验证 (1天)

**测试内容**:
- 存储接口测试
- 115网盘功能测试
- RClone功能测试
- OpenList功能测试
- 数据模型一致性测试

---

## 阶段3: 改进115网盘集成（优先级：中）

### 目标
使用PKCE认证和OSS上传，提高安全性和性能。

### 实施步骤

#### 3.1 实现PKCE认证 (2天)

**文件**: `backend/app/modules/cloud_storage/providers/u115.py`

```python
"""
115网盘提供者（PKCE认证）
"""

import base64
import hashlib
import secrets
from typing import Tuple, Optional
from loguru import logger


class U115Provider:
    """115网盘提供者"""
    
    def _generate_code_verifier(self) -> str:
        """生成code_verifier"""
        return base64.urlsafe_b64encode(secrets.token_bytes(32)).decode('utf-8').rstrip('=')
    
    def _generate_code_challenge(self, code_verifier: str) -> str:
        """生成code_challenge"""
        challenge = hashlib.sha256(code_verifier.encode('utf-8')).digest()
        return base64.urlsafe_b64encode(challenge).decode('utf-8').rstrip('=')
    
    async def generate_qrcode(self) -> Tuple[str, str]:
        """生成二维码"""
        code_verifier = self._generate_code_verifier()
        code_challenge = self._generate_code_challenge(code_verifier)
        
        # 构建二维码内容
        qr_content = self._build_qr_content(code_challenge)
        qr_url = self._get_qr_url(qr_content)
        
        return qr_content, qr_url
    
    async def check_login(self, ck: str, t: str) -> Tuple[Optional[Dict], Optional[str]]:
        """检查登录状态"""
        # 使用ck和t参数获取Token
        token = await self._exchange_token(ck, t)
        if token:
            # 存储Token
            await self._save_token(token)
            return token, None
        return None, "登录失败"
```

#### 3.2 实现OSS上传 (2天)

**文件**: `backend/app/modules/cloud_storage/providers/u115.py`

```python
    async def upload_file(self, local_path: str, remote_path: str) -> bool:
        """上传文件（使用OSS）"""
        # 获取OSS上传参数
        upload_params = await self._get_oss_upload_params(remote_path)
        if not upload_params:
            return False
        
        # 使用OSS multipart上传
        return await self._oss_multipart_upload(local_path, upload_params)
    
    async def _oss_multipart_upload(self, local_path: str, params: Dict[str, Any]) -> bool:
        """OSS multipart上传"""
        # 实现OSS multipart上传逻辑
        pass
```

#### 3.3 优化文件操作 (1天)

**优化内容**:
- 文件列表缓存
- 并发上传
- 断点续传
- 错误重试

#### 3.4 测试验证 (1天)

**测试内容**:
- PKCE认证测试
- OSS上传测试
- 文件操作测试
- 性能测试

---

## 阶段4: 优化前后端关联（优先级：中）

### 目标
清晰的前后端API端点映射，统一的数据模型。

### 实施步骤

#### 4.1 统一API端点 (1天)

**目标**: 使用RESTful风格统一API端点

**当前**:
- `/cloud-storage/{storage_id}/files`
- `/cloud-storage/{storage_id}/usage`

**优化后**:
- `/storage/{storage_id}/files` (统一前缀)
- `/storage/{storage_id}/usage`

#### 4.2 统一数据模型 (1天)

**目标**: 确保前后端使用相同的数据模型

**步骤**:
1. 检查现有数据模型
2. 统一命名规范
3. 添加数据验证
4. 更新文档

#### 4.3 优化错误处理 (1天)

**目标**: 统一的错误处理机制

**实现**:
```python
# backend/app/core/exceptions.py
class VabHubException(Exception):
    """VabHub基础异常"""
    def __init__(self, message: str, code: int = 500):
        self.message = message
        self.code = code
        super().__init__(self.message)

# 统一错误处理中间件
@app.exception_handler(VabHubException)
async def vabhub_exception_handler(request: Request, exc: VabHubException):
    return JSONResponse(
        status_code=exc.code,
        content={"success": False, "message": exc.message}
    )
```

#### 4.4 文档化 (1天)

**内容**:
- API文档更新
- 数据模型文档
- 错误码文档
- 使用示例

---

## 实施时间表

### 阶段1: Chain模式架构（2周）
- 第1周: 创建Chain基类和实现StorageChain、SubscribeChain
- 第2周: 实现DownloadChain、迁移现有代码、测试验证

### 阶段2: 存储抽象优化（1周）
- 第3周: 定义StorageBase、实现存储后端、统一数据模型、测试验证

### 阶段3: 115网盘集成改进（1周）
- 第4周: 实现PKCE认证、OSS上传、优化文件操作、测试验证

### 阶段4: 前后端关联优化（1周）
- 第5周: 统一API端点、统一数据模型、优化错误处理、文档化

### 总计
- **时间**: 5周
- **优先级**: 高（阶段1、2）→ 中（阶段3、4）
- **依赖**: 阶段1是基础，阶段2、3、4可以并行进行

---

## 风险评估

### 高风险
1. **Chain模式迁移**: 可能影响现有功能
   - **缓解**: 保持向后兼容，逐步迁移
   - **测试**: 充分测试每个迁移步骤

2. **存储抽象重构**: 可能影响现有存储功能
   - **缓解**: 先实现新接口，再迁移现有代码
   - **测试**: 完整的功能测试

### 中风险
1. **115网盘PKCE认证**: 可能遇到API变更
   - **缓解**: 保留现有Cookie认证作为备选
   - **测试**: 充分测试认证流程

2. **前后端关联优化**: 可能影响前端调用
   - **缓解**: 保持API兼容性，逐步优化
   - **测试**: 前端功能测试

---

## 成功标准

### 阶段1成功标准
- ✅ Chain基类创建完成
- ✅ StorageChain、SubscribeChain、DownloadChain实现完成
- ✅ 现有代码迁移完成
- ✅ 所有测试通过

### 阶段2成功标准
- ✅ StorageBase接口定义完成
- ✅ 115网盘、RClone、OpenList实现完成
- ✅ 数据模型统一完成
- ✅ 所有测试通过

### 阶段3成功标准
- ✅ PKCE认证实现完成
- ✅ OSS上传实现完成
- ✅ 文件操作优化完成
- ✅ 所有测试通过

### 阶段4成功标准
- ✅ API端点统一完成
- ✅ 数据模型统一完成
- ✅ 错误处理优化完成
- ✅ 文档更新完成

---

## 下一步行动

### 立即开始（本周）
1. **创建Chain基类**: 开始实施阶段1.1
2. **创建目录结构**: 创建 `backend/app/chain/` 目录
3. **编写测试用例**: 为Chain模式编写测试用例

### 本周计划
- [ ] 完成Chain基类创建
- [ ] 完成StorageChain实现
- [ ] 完成SubscribeChain实现
- [ ] 编写单元测试

### 下周计划
- [ ] 完成DownloadChain实现
- [ ] 开始迁移现有代码
- [ ] 进行集成测试

---

**计划版本**: 1.0  
**创建日期**: 2025-01-XX  
**最后更新**: 2025-01-XX  
**状态**: 待实施

