# åŸç”ŸSTRMç³»ç»Ÿè®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ è®¾è®¡ç†å¿µ

**ç³»ç»ŸåŸç”Ÿé›†æˆSTRMï¼Œæä¾›å®Œæ•´çš„è‡ªåŠ¨åŒ–å·¥ä½œæµï¼Œæ¯”ç¬¬ä¸‰æ–¹æ’ä»¶æ›´å¼ºå¤§ã€æ›´æ™ºèƒ½ã€‚**

### æ ¸å¿ƒä¼˜åŠ¿
1. âœ… **å®Œæ•´å·¥ä½œæµ**ï¼šä»ä¸‹è½½åˆ°STRMç”Ÿæˆçš„ç«¯åˆ°ç«¯è‡ªåŠ¨åŒ–
2. âœ… **æ™ºèƒ½æ–‡ä»¶ç®¡ç†**ï¼šæ”¯æŒå¤åˆ¶/ç§»åŠ¨ï¼Œä¿ç•™åšç§æˆ–æ¸…ç†ç©ºé—´
3. âœ… **å­—å¹•åŒæ­¥å¤„ç†**ï¼šè‡ªåŠ¨ä¸Šä¼ å’Œç”Ÿæˆå­—å¹•æ–‡ä»¶
4. âœ… **å¤šåª’ä½“æœåŠ¡å™¨æ”¯æŒ**ï¼šPlexã€Jellyfinã€Emby
5. âœ… **çµæ´»é…ç½®**ï¼šå¯é€‰çš„ç½‘ç›˜åˆ®å‰Šã€STRMç”Ÿæˆã€åª’ä½“åº“åˆ·æ–°
6. âœ… **å¢é‡æ›´æ–°**ï¼šæ–‡ä»¶æ ‘ç®¡ç†å’Œå¢é‡STRMç”Ÿæˆ

## ğŸ¯ å®Œæ•´å·¥ä½œæµç¨‹

```
1. ä¸‹è½½å®Œæˆ
   â†“
2. æ–‡ä»¶è¯†åˆ«å’Œé‡å‘½å
   â”œâ”€â”€ è¯†åˆ«åª’ä½“ä¿¡æ¯ï¼ˆTMDB/è±†ç“£ï¼‰
   â”œâ”€â”€ é‡å‘½åæ–‡ä»¶
   â””â”€â”€ åˆ†ç±»æ•´ç†
   â†“
3. å­—å¹•å¤„ç†ï¼ˆå¦‚æœæœ‰ï¼‰
   â”œâ”€â”€ è¯†åˆ«å­—å¹•æ–‡ä»¶
   â”œâ”€â”€ é‡å‘½åå­—å¹•æ–‡ä»¶
   â””â”€â”€ å‡†å¤‡ä¸Šä¼ 
   â†“
4. ä¸Šä¼ åˆ°ç½‘ç›˜
   â”œâ”€â”€ é€‰æ‹©ä¸Šä¼ æ¨¡å¼ï¼ˆå¤åˆ¶/ç§»åŠ¨ï¼‰
   â”œâ”€â”€ ä¸Šä¼ åª’ä½“æ–‡ä»¶
   â”œâ”€â”€ ä¸Šä¼ å­—å¹•æ–‡ä»¶
   â””â”€â”€ ç½‘ç›˜å†…é‡å‘½åå’Œåˆ†ç±»
   â†“
5. ç½‘ç›˜åˆ®å‰Šï¼ˆå¯é€‰ï¼‰
   â”œâ”€â”€ åœ¨ç½‘ç›˜è¿›è¡Œå…ƒæ•°æ®åˆ®å‰Š
   â””â”€â”€ æ›´æ–°ç½‘ç›˜æ–‡ä»¶ä¿¡æ¯
   â†“
6. ç”ŸæˆSTRMæ–‡ä»¶åˆ°æœ¬åœ°åª’ä½“åº“
   â”œâ”€â”€ å¯¹åº”ç½‘ç›˜ç›®å½•ç»“æ„
   â”œâ”€â”€ ç”ŸæˆSTRMæ–‡ä»¶
   â”œâ”€â”€ ç”Ÿæˆå­—å¹•æ–‡ä»¶ï¼ˆå¦‚æœæœ‰ï¼‰
   â””â”€â”€ ç”ŸæˆNFOæ–‡ä»¶ï¼ˆå…ƒæ•°æ®ï¼‰
   â†“
7. æœ¬åœ°åˆ®å‰Š
   â”œâ”€â”€ å¯¹STRMæ–‡ä»¶è¿›è¡Œå…ƒæ•°æ®åˆ®å‰Š
   â””â”€â”€ ä¸‹è½½æµ·æŠ¥ã€å‰§ç…§ç­‰
   â†“
8. é€šçŸ¥åª’ä½“æœåŠ¡å™¨åˆ·æ–°
   â”œâ”€â”€ Plexåˆ·æ–°
   â”œâ”€â”€ Jellyfinåˆ·æ–°
   â””â”€â”€ Embyåˆ·æ–°
   â†“
9. æ¸…ç†æœ¬åœ°æ–‡ä»¶ï¼ˆå¦‚æœé€‰æ‹©ç§»åŠ¨æ¨¡å¼ï¼‰
   â”œâ”€â”€ åˆ é™¤å·²ä¸Šä¼ çš„æºæ–‡ä»¶
   â””â”€â”€ åˆ é™¤ç©ºæ–‡ä»¶å¤¹
```

## ğŸ“ ç³»ç»Ÿæ¶æ„

### 1. æ ¸å¿ƒæ¨¡å—

```
backend/app/modules/strm/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ generator.py              # STRMæ–‡ä»¶ç”Ÿæˆå™¨
â”œâ”€â”€ workflow.py               # STRMå·¥ä½œæµç®¡ç†å™¨
â”œâ”€â”€ uploader.py               # æ–‡ä»¶ä¸Šä¼ ç®¡ç†å™¨
â”œâ”€â”€ subtitle_handler.py       # å­—å¹•æ–‡ä»¶å¤„ç†å™¨
â”œâ”€â”€ scraper.py                # å…ƒæ•°æ®åˆ®å‰Šå™¨ï¼ˆæœ¬åœ°/ç½‘ç›˜ï¼‰
â”œâ”€â”€ media_server_notifier.py  # åª’ä½“æœåŠ¡å™¨é€šçŸ¥å™¨
â”œâ”€â”€ file_tree_manager.py      # æ–‡ä»¶æ ‘ç®¡ç†å™¨
â””â”€â”€ config.py                 # STRMé…ç½®ç®¡ç†
```

### 2. æ•°æ®æ¨¡å‹

```python
# backend/app/models/strm.py

class STRMWorkflowTask(Base):
    """STRMå·¥ä½œæµä»»åŠ¡"""
    id: int
    download_task_id: int          # å…³è”çš„ä¸‹è½½ä»»åŠ¡ID
    media_file_path: str           # æœ¬åœ°åª’ä½“æ–‡ä»¶è·¯å¾„
    subtitle_files: List[str]      # å­—å¹•æ–‡ä»¶åˆ—è¡¨
    upload_mode: str               # ä¸Šä¼ æ¨¡å¼ï¼šcopy/move
    cloud_storage: str             # äº‘å­˜å‚¨ç±»å‹ï¼š115/123
    cloud_path: str                # äº‘å­˜å‚¨è·¯å¾„
    strm_path: str                 # STRMæ–‡ä»¶è·¯å¾„
    status: str                    # ä»»åŠ¡çŠ¶æ€
    progress: float                # è¿›åº¦ï¼ˆ0-100ï¼‰
    metadata: Dict                 # åª’ä½“å…ƒæ•°æ®
    created_at: datetime
    updated_at: datetime

class STRMFile(Base):
    """STRMæ–‡ä»¶è®°å½•"""
    id: int
    media_file_id: int             # å…³è”çš„åª’ä½“æ–‡ä»¶ID
    strm_path: str                 # STRMæ–‡ä»¶è·¯å¾„
    cloud_file_id: str             # äº‘å­˜å‚¨æ–‡ä»¶ID
    cloud_storage: str             # äº‘å­˜å‚¨ç±»å‹
    media_type: str                # åª’ä½“ç±»å‹ï¼šmovie/tv
    title: str                     # æ ‡é¢˜
    year: int                      # å¹´ä»½
    season: int                    # å­£ï¼ˆç”µè§†å‰§ï¼‰
    episode: int                   # é›†ï¼ˆç”µè§†å‰§ï¼‰
    subtitle_files: List[str]      # å­—å¹•æ–‡ä»¶åˆ—è¡¨
    nfo_path: str                  # NFOæ–‡ä»¶è·¯å¾„
    created_at: datetime
    updated_at: datetime

class STRMFileTree(Base):
    """STRMæ–‡ä»¶æ ‘è®°å½•"""
    id: int
    path: str                      # æ–‡ä»¶è·¯å¾„ï¼ˆå”¯ä¸€ï¼‰
    file_id: int                   # æ–‡ä»¶ID
    parent_id: int                 # çˆ¶ç›®å½•ID
    file_name: str                 # æ–‡ä»¶å
    file_type: str                 # æ–‡ä»¶ç±»å‹ï¼šfile/folder
    file_size: BigInteger          # æ–‡ä»¶å¤§å°
    sha1: str                      # æ–‡ä»¶SHA1
    cloud_file_id: str             # äº‘å­˜å‚¨æ–‡ä»¶ID
    cloud_storage: str             # äº‘å­˜å‚¨ç±»å‹
    update_time: BigInteger        # æ›´æ–°æ—¶é—´
    create_time: BigInteger        # åˆ›å»ºæ—¶é—´

class STRMLifeEvent(Base):
    """STRMç”Ÿå‘½å‘¨æœŸäº‹ä»¶"""
    id: int
    type: int                      # äº‹ä»¶ç±»å‹ï¼š1-åˆ›å»ºï¼Œ2-æ›´æ–°ï¼Œ3-åˆ é™¤
    file_id: int                   # æ–‡ä»¶ID
    parent_id: int                 # çˆ¶ç›®å½•ID
    file_name: str                 # æ–‡ä»¶å
    file_category: int             # æ–‡ä»¶åˆ†ç±»
    file_type: int                 # æ–‡ä»¶ç±»å‹
    file_size: BigInteger          # æ–‡ä»¶å¤§å°
    sha1: str                      # æ–‡ä»¶SHA1
    pick_code: str                 # äº‘å­˜å‚¨pick_code
    update_time: BigInteger        # æ›´æ–°æ—¶é—´
    create_time: BigInteger        # åˆ›å»ºæ—¶é—´
```

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½å®ç°

### 1. STRMæ–‡ä»¶ç”Ÿæˆå™¨

```python
# backend/app/modules/strm/generator.py

class STRMGenerator:
    """STRMæ–‡ä»¶ç”Ÿæˆå™¨"""
    
    def __init__(self, config: STRMConfig):
        self.config = config
        self.media_library_path = config.media_library_path
        self.cloud_storage_mapping = config.cloud_storage_mapping
    
    async def generate_strm_file(
        self,
        media_info: Dict[str, Any],
        cloud_file_id: str,
        cloud_storage: str,
        cloud_path: str,
        subtitle_files: Optional[List[str]] = None
    ) -> Dict[str, str]:
        """
        ç”ŸæˆSTRMæ–‡ä»¶
        
        Args:
            media_info: åª’ä½“ä¿¡æ¯
            cloud_file_id: äº‘å­˜å‚¨æ–‡ä»¶ID
            cloud_storage: äº‘å­˜å‚¨ç±»å‹ï¼ˆ115/123ï¼‰
            cloud_path: äº‘å­˜å‚¨è·¯å¾„
            subtitle_files: å­—å¹•æ–‡ä»¶åˆ—è¡¨
        
        Returns:
            ç”Ÿæˆçš„æ–‡ä»¶è·¯å¾„å­—å…¸
        """
        # 1. æ„å»ºæœ¬åœ°åª’ä½“åº“è·¯å¾„ï¼ˆå¯¹åº”ç½‘ç›˜ç›®å½•ç»“æ„ï¼‰
        local_path = self._build_local_path(media_info, cloud_path)
        
        # 2. ç”ŸæˆSTRMæ–‡ä»¶
        strm_path = await self._generate_strm(
            local_path, cloud_file_id, cloud_storage, media_info
        )
        
        # 3. ç”Ÿæˆå­—å¹•æ–‡ä»¶ï¼ˆå¦‚æœæœ‰ï¼‰
        subtitle_paths = []
        if subtitle_files:
            subtitle_paths = await self._generate_subtitle_files(
                local_path, subtitle_files, media_info
            )
        
        # 4. ç”ŸæˆNFOæ–‡ä»¶
        nfo_path = await self._generate_nfo(local_path, media_info)
        
        return {
            'strm_path': strm_path,
            'subtitle_paths': subtitle_paths,
            'nfo_path': nfo_path
        }
    
    def _build_local_path(
        self,
        media_info: Dict[str, Any],
        cloud_path: str
    ) -> Path:
        """æ„å»ºæœ¬åœ°åª’ä½“åº“è·¯å¾„ï¼ˆå¯¹åº”ç½‘ç›˜ç›®å½•ç»“æ„ï¼‰"""
        # æ ¹æ®äº‘å­˜å‚¨è·¯å¾„æ˜ å°„åˆ°æœ¬åœ°åª’ä½“åº“è·¯å¾„
        # ä¾‹å¦‚ï¼š/115/ç”µå½±/xxx (2023)/xxx (2023).mkv
        # æ˜ å°„åˆ°ï¼š/media_library/Movies/xxx (2023)/xxx (2023).strm
        
        media_type = media_info.get('type')
        if media_type == 'movie':
            base_path = Path(self.media_library_path) / 'Movies'
        elif media_type == 'tv':
            base_path = Path(self.media_library_path) / 'TV Shows'
        else:
            base_path = Path(self.media_library_path) / 'Other'
        
        # ä»äº‘å­˜å‚¨è·¯å¾„æå–ç›¸å¯¹è·¯å¾„
        # ä¾‹å¦‚ï¼š/115/ç”µå½±/xxx (2023)/xxx (2023).mkv
        # æå–ï¼šç”µå½±/xxx (2023)/
        relative_path = self._extract_relative_path(cloud_path)
        
        return base_path / relative_path
```

### 2. æ–‡ä»¶ä¸Šä¼ ç®¡ç†å™¨

```python
# backend/app/modules/strm/uploader.py

class FileUploader:
    """æ–‡ä»¶ä¸Šä¼ ç®¡ç†å™¨"""
    
    def __init__(self, config: STRMConfig):
        self.config = config
        self.cloud_clients = {}  # äº‘å­˜å‚¨å®¢æˆ·ç«¯
    
    async def upload_media_file(
        self,
        local_file_path: str,
        cloud_storage: str,
        cloud_target_path: str,
        upload_mode: str = 'copy',  # copy/move
        rename_file: bool = True,
        organize_by_type: bool = True
    ) -> Dict[str, Any]:
        """
        ä¸Šä¼ åª’ä½“æ–‡ä»¶åˆ°ç½‘ç›˜
        
        Args:
            local_file_path: æœ¬åœ°æ–‡ä»¶è·¯å¾„
            cloud_storage: äº‘å­˜å‚¨ç±»å‹ï¼ˆ115/123ï¼‰
            cloud_target_path: äº‘å­˜å‚¨ç›®æ ‡è·¯å¾„
            upload_mode: ä¸Šä¼ æ¨¡å¼ï¼ˆcopy/moveï¼‰
            rename_file: æ˜¯å¦é‡å‘½åæ–‡ä»¶
            organize_by_type: æ˜¯å¦æŒ‰ç±»å‹ç»„ç»‡
        
        Returns:
            ä¸Šä¼ ç»“æœ
        """
        # 1. è¯†åˆ«åª’ä½“æ–‡ä»¶
        media_info = await self._identify_media(local_file_path)
        
        # 2. é‡å‘½åæ–‡ä»¶ï¼ˆå¦‚æœéœ€è¦ï¼‰
        if rename_file:
            new_name = self._generate_cloud_filename(media_info)
            cloud_target_path = f"{cloud_target_path}/{new_name}"
        
        # 3. ä¸Šä¼ æ–‡ä»¶
        upload_result = await self._upload_file(
            local_file_path, cloud_storage, cloud_target_path
        )
        
        # 4. å¤„ç†ä¸Šä¼ æ¨¡å¼
        if upload_mode == 'move':
            # ç§»åŠ¨æ¨¡å¼ï¼šä¸Šä¼ å®Œæˆååˆ é™¤æœ¬åœ°æ–‡ä»¶
            await self._delete_local_file(local_file_path)
            # åˆ é™¤ç©ºæ–‡ä»¶å¤¹
            await self._cleanup_empty_folders(local_file_path)
        # copyæ¨¡å¼ï¼šä¿ç•™æœ¬åœ°æ–‡ä»¶ï¼Œå¯ä»¥ç»§ç»­åšç§
        
        return {
            'success': True,
            'cloud_file_id': upload_result['file_id'],
            'cloud_path': upload_result['path'],
            'media_info': media_info
        }
    
    async def upload_with_subtitles(
        self,
        media_file_path: str,
        subtitle_files: List[str],
        cloud_storage: str,
        cloud_target_path: str,
        upload_mode: str = 'copy'
    ) -> Dict[str, Any]:
        """
        ä¸Šä¼ åª’ä½“æ–‡ä»¶å’Œå­—å¹•æ–‡ä»¶
        
        Args:
            media_file_path: åª’ä½“æ–‡ä»¶è·¯å¾„
            subtitle_files: å­—å¹•æ–‡ä»¶åˆ—è¡¨
            cloud_storage: äº‘å­˜å‚¨ç±»å‹
            cloud_target_path: äº‘å­˜å‚¨ç›®æ ‡è·¯å¾„
            upload_mode: ä¸Šä¼ æ¨¡å¼
        
        Returns:
            ä¸Šä¼ ç»“æœ
        """
        # 1. ä¸Šä¼ åª’ä½“æ–‡ä»¶
        media_result = await self.upload_media_file(
            media_file_path, cloud_storage, cloud_target_path, upload_mode
        )
        
        # 2. ä¸Šä¼ å­—å¹•æ–‡ä»¶
        subtitle_results = []
        for subtitle_file in subtitle_files:
            # é‡å‘½åå­—å¹•æ–‡ä»¶ï¼ˆåŒ¹é…åª’ä½“æ–‡ä»¶åï¼‰
            subtitle_name = self._generate_subtitle_name(
                media_result['media_info'], subtitle_file
            )
            subtitle_path = f"{cloud_target_path}/{subtitle_name}"
            
            subtitle_result = await self._upload_file(
                subtitle_file, cloud_storage, subtitle_path
            )
            subtitle_results.append(subtitle_result)
            
            # å¤„ç†ä¸Šä¼ æ¨¡å¼
            if upload_mode == 'move':
                await self._delete_local_file(subtitle_file)
        
        return {
            'media': media_result,
            'subtitles': subtitle_results
        }
```

### 3. å­—å¹•æ–‡ä»¶å¤„ç†å™¨

```python
# backend/app/modules/strm/subtitle_handler.py

class SubtitleHandler:
    """å­—å¹•æ–‡ä»¶å¤„ç†å™¨"""
    
    async def find_subtitle_files(
        self,
        media_file_path: str
    ) -> List[str]:
        """
        æŸ¥æ‰¾åª’ä½“æ–‡ä»¶å…³è”çš„å­—å¹•æ–‡ä»¶
        
        Args:
            media_file_path: åª’ä½“æ–‡ä»¶è·¯å¾„
        
        Returns:
            å­—å¹•æ–‡ä»¶åˆ—è¡¨
        """
        media_path = Path(media_file_path)
        media_dir = media_path.parent
        media_stem = media_path.stem
        
        # æŸ¥æ‰¾åŒåçš„å­—å¹•æ–‡ä»¶
        subtitle_extensions = ['.srt', '.ass', '.ssa', '.vtt']
        subtitle_files = []
        
        for ext in subtitle_extensions:
            # ç²¾ç¡®åŒ¹é…ï¼šmovie.srt
            subtitle_path = media_dir / f"{media_stem}{ext}"
            if subtitle_path.exists():
                subtitle_files.append(str(subtitle_path))
            
            # è¯­è¨€åŒ¹é…ï¼šmovie.chi.zh-cn.srt
            for lang_code in ['chi', 'eng', 'zh-cn', 'en']:
                subtitle_path = media_dir / f"{media_stem}.{lang_code}{ext}"
                if subtitle_path.exists():
                    subtitle_files.append(str(subtitle_path))
        
        return subtitle_files
    
    def generate_subtitle_name(
        self,
        media_info: Dict[str, Any],
        subtitle_file: str,
        language: str = 'chi'
    ) -> str:
        """
        ç”Ÿæˆå­—å¹•æ–‡ä»¶åï¼ˆåŒ¹é…åª’ä½“æ–‡ä»¶åï¼‰
        
        Args:
            media_info: åª’ä½“ä¿¡æ¯
            subtitle_file: å­—å¹•æ–‡ä»¶è·¯å¾„
            language: è¯­è¨€ä»£ç 
        
        Returns:
            æ–°çš„å­—å¹•æ–‡ä»¶å
        """
        media_type = media_info.get('type')
        
        if media_type == 'movie':
            # ç”µå½±ï¼šTitle (Year).chi.srt
            base_name = f"{media_info['title']} ({media_info.get('year', '')})"
        elif media_type == 'tv':
            # ç”µè§†å‰§ï¼šTitle - S01E01.chi.srt
            base_name = f"{media_info['title']} - S{media_info.get('season', 1):02d}E{media_info.get('episode', 1):02d}"
        else:
            base_name = media_info.get('title', 'unknown')
        
        # è·å–å­—å¹•æ–‡ä»¶æ‰©å±•å
        subtitle_ext = Path(subtitle_file).suffix
        
        return f"{base_name}.{language}{subtitle_ext}"
    
    async def generate_subtitle_strm(
        self,
        strm_path: str,
        subtitle_files: List[str],
        media_info: Dict[str, Any]
    ) -> List[str]:
        """
        ç”Ÿæˆå­—å¹•æ–‡ä»¶åˆ°STRMç›®å½•
        
        Args:
            strm_path: STRMæ–‡ä»¶è·¯å¾„
            subtitle_files: å­—å¹•æ–‡ä»¶åˆ—è¡¨ï¼ˆäº‘å­˜å‚¨è·¯å¾„ï¼‰
            media_info: åª’ä½“ä¿¡æ¯
        
        Returns:
            ç”Ÿæˆçš„å­—å¹•æ–‡ä»¶è·¯å¾„åˆ—è¡¨
        """
        strm_dir = Path(strm_path).parent
        subtitle_paths = []
        
        for subtitle_file in subtitle_files:
            # ä»äº‘å­˜å‚¨è·¯å¾„æå–æ–‡ä»¶å
            subtitle_name = Path(subtitle_file).name
            
            # ç”Ÿæˆæœ¬åœ°å­—å¹•æ–‡ä»¶è·¯å¾„
            local_subtitle_path = strm_dir / subtitle_name
            
            # åˆ›å»ºå­—å¹•æ–‡ä»¶ï¼ˆæŒ‡å‘äº‘å­˜å‚¨ï¼‰
            # æ³¨æ„ï¼šå­—å¹•æ–‡ä»¶é€šå¸¸æ˜¯ç›´æ¥ä¸‹è½½ï¼Œä¸æ˜¯STRMæ ¼å¼
            # ä½†æˆ‘ä»¬å¯ä»¥åˆ›å»ºè½¯é“¾æ¥æˆ–å¤åˆ¶
            subtitle_paths.append(str(local_subtitle_path))
        
        return subtitle_paths
```

### 4. STRMå·¥ä½œæµç®¡ç†å™¨

```python
# backend/app/modules/strm/workflow.py

class STRMWorkflowManager:
    """STRMå·¥ä½œæµç®¡ç†å™¨"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self.uploader = FileUploader()
        self.generator = STRMGenerator()
        self.subtitle_handler = SubtitleHandler()
        self.scraper = MediaScraper()
        self.notifier = MediaServerNotifier()
    
    async def process_download_complete(
        self,
        download_task_id: int,
        media_file_path: str,
        config: STRMWorkflowConfig
    ) -> STRMWorkflowTask:
        """
        å¤„ç†ä¸‹è½½å®Œæˆçš„å·¥ä½œæµ
        
        Args:
            download_task_id: ä¸‹è½½ä»»åŠ¡ID
            media_file_path: åª’ä½“æ–‡ä»¶è·¯å¾„
            config: å·¥ä½œæµé…ç½®
        
        Returns:
            STRMå·¥ä½œæµä»»åŠ¡
        """
        # 1. åˆ›å»ºå·¥ä½œä»»åŠ¡
        task = STRMWorkflowTask(
            download_task_id=download_task_id,
            media_file_path=media_file_path,
            upload_mode=config.upload_mode,
            cloud_storage=config.cloud_storage,
            status='pending'
        )
        self.db.add(task)
        await self.db.commit()
        
        try:
            # 2. æ–‡ä»¶è¯†åˆ«å’Œé‡å‘½å
            task.status = 'identifying'
            task.progress = 10
            await self.db.commit()
            
            media_info = await self._identify_media(media_file_path)
            task.metadata = media_info
            
            # 3. æŸ¥æ‰¾å­—å¹•æ–‡ä»¶
            task.status = 'finding_subtitles'
            task.progress = 20
            await self.db.commit()
            
            subtitle_files = await self.subtitle_handler.find_subtitle_files(
                media_file_path
            )
            task.subtitle_files = subtitle_files
            
            # 4. ä¸Šä¼ åˆ°ç½‘ç›˜
            task.status = 'uploading'
            task.progress = 30
            await self.db.commit()
            
            upload_result = await self.uploader.upload_with_subtitles(
                media_file_path=media_file_path,
                subtitle_files=subtitle_files,
                cloud_storage=config.cloud_storage,
                cloud_target_path=config.cloud_target_path,
                upload_mode=config.upload_mode
            )
            task.cloud_path = upload_result['media']['cloud_path']
            
            # 5. ç½‘ç›˜åˆ®å‰Šï¼ˆå¯é€‰ï¼‰
            if config.scrape_on_cloud:
                task.status = 'scraping_cloud'
                task.progress = 50
                await self.db.commit()
                
                await self.scraper.scrape_cloud_file(
                    cloud_storage=config.cloud_storage,
                    cloud_file_id=upload_result['media']['cloud_file_id'],
                    media_info=media_info
                )
            
            # 6. ç”ŸæˆSTRMæ–‡ä»¶
            task.status = 'generating_strm'
            task.progress = 60
            await self.db.commit()
            
            strm_result = await self.generator.generate_strm_file(
                media_info=media_info,
                cloud_file_id=upload_result['media']['cloud_file_id'],
                cloud_storage=config.cloud_storage,
                cloud_path=upload_result['media']['cloud_path'],
                subtitle_files=subtitle_files
            )
            task.strm_path = strm_result['strm_path']
            
            # 7. æœ¬åœ°åˆ®å‰Š
            task.status = 'scraping_local'
            task.progress = 80
            await self.db.commit()
            
            await self.scraper.scrape_local_strm(
                strm_path=strm_result['strm_path'],
                media_info=media_info
            )
            
            # 8. é€šçŸ¥åª’ä½“æœåŠ¡å™¨åˆ·æ–°
            task.status = 'refreshing_media_server'
            task.progress = 90
            await self.db.commit()
            
            await self.notifier.refresh_media_servers(
                media_servers=config.media_servers,  # ['plex', 'jellyfin', 'emby']
                strm_path=strm_result['strm_path'],
                media_info=media_info
            )
            
            # 9. å®Œæˆ
            task.status = 'completed'
            task.progress = 100
            await self.db.commit()
            
            return task
            
        except Exception as e:
            task.status = 'failed'
            task.error_message = str(e)
            await self.db.commit()
            raise
```

### 5. åª’ä½“æœåŠ¡å™¨é€šçŸ¥å™¨

```python
# backend/app/modules/strm/media_server_notifier.py

class MediaServerNotifier:
    """åª’ä½“æœåŠ¡å™¨é€šçŸ¥å™¨"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self.plex_client = None
        self.jellyfin_client = None
        self.emby_client = None
    
    async def refresh_media_servers(
        self,
        media_servers: List[str],
        strm_path: str,
        media_info: Dict[str, Any]
    ):
        """
        é€šçŸ¥åª’ä½“æœåŠ¡å™¨åˆ·æ–°
        
        Args:
            media_servers: åª’ä½“æœåŠ¡å™¨åˆ—è¡¨ï¼ˆ['plex', 'jellyfin', 'emby']ï¼‰
            strm_path: STRMæ–‡ä»¶è·¯å¾„
            media_info: åª’ä½“ä¿¡æ¯
        """
        tasks = []
        
        for server in media_servers:
            if server == 'plex':
                tasks.append(self._refresh_plex(strm_path, media_info))
            elif server == 'jellyfin':
                tasks.append(self._refresh_jellyfin(strm_path, media_info))
            elif server == 'emby':
                tasks.append(self._refresh_emby(strm_path, media_info))
        
        await asyncio.gather(*tasks, return_exceptions=True)
    
    async def _refresh_plex(self, strm_path: str, media_info: Dict[str, Any]):
        """åˆ·æ–°Plexåª’ä½“åº“"""
        from app.modules.media_server.plex_client import PlexClient
        
        # è·å–Plexå®¢æˆ·ç«¯
        plex_servers = await self._get_media_servers('plex')
        
        for server in plex_servers:
            client = PlexClient(server)
            # åˆ·æ–°åª’ä½“åº“
            await client.refresh_library(strm_path)
    
    async def _refresh_jellyfin(self, strm_path: str, media_info: Dict[str, Any]):
        """åˆ·æ–°Jellyfinåª’ä½“åº“"""
        from app.modules.media_server.jellyfin_client import JellyfinClient
        
        # è·å–Jellyfinå®¢æˆ·ç«¯
        jellyfin_servers = await self._get_media_servers('jellyfin')
        
        for server in jellyfin_servers:
            client = JellyfinClient(server)
            # åˆ·æ–°åª’ä½“åº“
            await client.refresh_library(strm_path)
    
    async def _refresh_emby(self, strm_path: str, media_info: Dict[str, Any]):
        """åˆ·æ–°Embyåª’ä½“åº“"""
        from app.modules.media_server.emby_client import EmbyClient
        
        # è·å–Embyå®¢æˆ·ç«¯
        emby_servers = await self._get_media_servers('emby')
        
        for server in emby_servers:
            client = EmbyClient(server)
            # åˆ·æ–°åª’ä½“åº“
            await client.refresh_library(strm_path)
```

### 6. æ–‡ä»¶æ ‘ç®¡ç†å™¨

```python
# backend/app/modules/strm/file_tree_manager.py

class FileTreeManager:
    """æ–‡ä»¶æ ‘ç®¡ç†å™¨ï¼ˆå‚è€ƒMoviePilotæ’ä»¶ï¼‰"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def scan_cloud_storage(
        self,
        cloud_storage: str,
        root_path: str = '/'
    ) -> Dict[str, Any]:
        """
        æ‰«æäº‘å­˜å‚¨æ–‡ä»¶æ ‘
        
        Args:
            cloud_storage: äº‘å­˜å‚¨ç±»å‹ï¼ˆ115/123ï¼‰
            root_path: æ ¹è·¯å¾„
        
        Returns:
            æ–‡ä»¶æ ‘ç»“æ„
        """
        # 1. è·å–äº‘å­˜å‚¨å®¢æˆ·ç«¯
        client = await self._get_cloud_client(cloud_storage)
        
        # 2. é€’å½’æ‰«ææ–‡ä»¶æ ‘
        file_tree = await self._scan_directory(client, root_path)
        
        # 3. ä¿å­˜åˆ°æ•°æ®åº“
        await self._save_file_tree(cloud_storage, file_tree)
        
        return file_tree
    
    async def compare_file_trees(
        self,
        cloud_storage: str,
        local_tree: Dict[str, Any],
        cloud_tree: Dict[str, Any]
    ) -> Dict[str, List[str]]:
        """
        å¯¹æ¯”æœ¬åœ°å’Œäº‘å­˜å‚¨æ–‡ä»¶æ ‘
        
        Args:
            cloud_storage: äº‘å­˜å‚¨ç±»å‹
            local_tree: æœ¬åœ°æ–‡ä»¶æ ‘
            cloud_tree: äº‘å­˜å‚¨æ–‡ä»¶æ ‘
        
        Returns:
            å·®å¼‚ç»“æœï¼šæ–°å¢ã€æ›´æ–°ã€åˆ é™¤çš„æ–‡ä»¶åˆ—è¡¨
        """
        differences = {
            'added': [],      # æ–°å¢çš„æ–‡ä»¶
            'updated': [],    # æ›´æ–°çš„æ–‡ä»¶
            'deleted': []     # åˆ é™¤çš„æ–‡ä»¶
        }
        
        # å¯¹æ¯”æ–‡ä»¶æ ‘
        local_files = self._flatten_tree(local_tree)
        cloud_files = self._flatten_tree(cloud_tree)
        
        local_file_map = {f['path']: f for f in local_files}
        cloud_file_map = {f['path']: f for f in cloud_files}
        
        # æ‰¾å‡ºæ–°å¢å’Œæ›´æ–°çš„æ–‡ä»¶
        for cloud_path, cloud_file in cloud_file_map.items():
            if cloud_path not in local_file_map:
                differences['added'].append(cloud_path)
            else:
                local_file = local_file_map[cloud_path]
                if cloud_file['sha1'] != local_file.get('sha1'):
                    differences['updated'].append(cloud_path)
        
        # æ‰¾å‡ºåˆ é™¤çš„æ–‡ä»¶
        for local_path in local_file_map:
            if local_path not in cloud_file_map:
                differences['deleted'].append(local_path)
        
        return differences
    
    async def incremental_generate_strm(
        self,
        cloud_storage: str,
        differences: Dict[str, List[str]],
        overwrite_mode: str = 'never'  # never/always/smart
    ) -> Dict[str, Any]:
        """
        å¢é‡ç”ŸæˆSTRMæ–‡ä»¶
        
        Args:
            cloud_storage: äº‘å­˜å‚¨ç±»å‹
            differences: æ–‡ä»¶å·®å¼‚
            overwrite_mode: è¦†ç›–æ¨¡å¼
        
        Returns:
            ç”Ÿæˆç»“æœ
        """
        results = {
            'generated': [],
            'skipped': [],
            'failed': []
        }
        
        # å¤„ç†æ–°å¢å’Œæ›´æ–°çš„æ–‡ä»¶
        files_to_process = differences['added'] + differences['updated']
        
        for file_path in files_to_process:
            # æ£€æŸ¥è¦†ç›–æ¨¡å¼
            if overwrite_mode == 'never':
                # æ£€æŸ¥STRMæ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
                strm_path = await self._get_strm_path(file_path)
                if strm_path and Path(strm_path).exists():
                    results['skipped'].append(file_path)
                    continue
            
            # ç”ŸæˆSTRMæ–‡ä»¶
            try:
                strm_result = await self._generate_strm_for_file(
                    cloud_storage, file_path
                )
                results['generated'].append(file_path)
            except Exception as e:
                results['failed'].append({'path': file_path, 'error': str(e)})
        
        return results
```

## ğŸ”§ é…ç½®æ¨¡å‹

```python
# backend/app/modules/strm/config.py

class STRMWorkflowConfig(BaseModel):
    """STRMå·¥ä½œæµé…ç½®"""
    # ä¸Šä¼ é…ç½®
    upload_mode: str = 'copy'  # copy/move
    cloud_storage: str = '115'  # 115/123
    cloud_target_path: str = '/ç”µå½±'  # äº‘å­˜å‚¨ç›®æ ‡è·¯å¾„
    rename_on_upload: bool = True  # ä¸Šä¼ æ—¶é‡å‘½å
    organize_by_type: bool = True  # æŒ‰ç±»å‹ç»„ç»‡
    
    # å­—å¹•é…ç½®
    upload_subtitles: bool = True  # ä¸Šä¼ å­—å¹•æ–‡ä»¶
    rename_subtitles: bool = True  # é‡å‘½åå­—å¹•æ–‡ä»¶
    generate_subtitle_files: bool = True  # ç”Ÿæˆå­—å¹•æ–‡ä»¶åˆ°STRMç›®å½•
    
    # åˆ®å‰Šé…ç½®
    scrape_on_cloud: bool = False  # åœ¨ç½‘ç›˜è¿›è¡Œåˆ®å‰Š
    scrape_on_local: bool = True  # åœ¨æœ¬åœ°è¿›è¡Œåˆ®å‰Š
    
    # STRMç”Ÿæˆé…ç½®
    generate_strm: bool = True  # ç”ŸæˆSTRMæ–‡ä»¶
    generate_nfo: bool = True  # ç”ŸæˆNFOæ–‡ä»¶
    media_library_path: str = '/media_library'  # æœ¬åœ°åª’ä½“åº“è·¯å¾„
    map_cloud_path: bool = True  # æ˜ å°„äº‘å­˜å‚¨è·¯å¾„åˆ°æœ¬åœ°
    
    # åª’ä½“æœåŠ¡å™¨é…ç½®
    media_servers: List[str] = ['plex', 'jellyfin', 'emby']  # åª’ä½“æœåŠ¡å™¨åˆ—è¡¨
    auto_refresh: bool = True  # è‡ªåŠ¨åˆ·æ–°åª’ä½“åº“
    refresh_delay: int = 300  # åˆ·æ–°å»¶è¿Ÿï¼ˆç§’ï¼‰
    
    # æ–‡ä»¶æ ‘é…ç½®
    enable_file_tree: bool = True  # å¯ç”¨æ–‡ä»¶æ ‘ç®¡ç†
    enable_incremental: bool = True  # å¯ç”¨å¢é‡æ›´æ–°
    overwrite_mode: str = 'never'  # è¦†ç›–æ¨¡å¼ï¼šnever/always/smart
```

## ğŸ“Š APIç«¯ç‚¹

### 1. å·¥ä½œæµAPI

```python
# backend/app/api/strm_workflow.py

@router.post("/workflow/start")
async def start_strm_workflow(
    download_task_id: int,
    config: STRMWorkflowConfig,
    db = Depends(get_db)
):
    """å¯åŠ¨STRMå·¥ä½œæµ"""
    workflow_manager = STRMWorkflowManager(db)
    task = await workflow_manager.process_download_complete(
        download_task_id, media_file_path, config
    )
    return task

@router.get("/workflow/{task_id}")
async def get_workflow_task(
    task_id: int,
    db = Depends(get_db)
):
    """è·å–å·¥ä½œæµä»»åŠ¡çŠ¶æ€"""
    # ...

@router.post("/workflow/{task_id}/cancel")
async def cancel_workflow_task(
    task_id: int,
    db = Depends(get_db)
):
    """å–æ¶ˆå·¥ä½œæµä»»åŠ¡"""
    # ...
```

### 2. STRMç”ŸæˆAPI

```python
@router.post("/generate")
async def generate_strm_file(
    media_info: Dict[str, Any],
    cloud_file_id: str,
    cloud_storage: str,
    cloud_path: str,
    db = Depends(get_db)
):
    """ç”ŸæˆSTRMæ–‡ä»¶"""
    generator = STRMGenerator()
    result = await generator.generate_strm_file(
        media_info, cloud_file_id, cloud_storage, cloud_path
    )
    return result

@router.post("/batch-generate")
async def batch_generate_strm(
    file_list: List[Dict[str, Any]],
    db = Depends(get_db)
):
    """æ‰¹é‡ç”ŸæˆSTRMæ–‡ä»¶"""
    # ...
```

### 3. æ–‡ä»¶æ ‘API

```python
@router.post("/file-tree/scan")
async def scan_file_tree(
    cloud_storage: str,
    root_path: str = '/',
    db = Depends(get_db)
):
    """æ‰«æäº‘å­˜å‚¨æ–‡ä»¶æ ‘"""
    tree_manager = FileTreeManager(db)
    file_tree = await tree_manager.scan_cloud_storage(cloud_storage, root_path)
    return file_tree

@router.post("/file-tree/incremental-generate")
async def incremental_generate_strm(
    cloud_storage: str,
    overwrite_mode: str = 'never',
    db = Depends(get_db)
):
    """å¢é‡ç”ŸæˆSTRMæ–‡ä»¶"""
    tree_manager = FileTreeManager(db)
    differences = await tree_manager.compare_file_trees(...)
    results = await tree_manager.incremental_generate_strm(
        cloud_storage, differences, overwrite_mode
    )
    return results
```

## ğŸ¯ å·¥ä½œæµç¨‹ç¤ºä¾‹

### ç¤ºä¾‹1ï¼šä¸‹è½½å®Œæˆåè‡ªåŠ¨ç”ŸæˆSTRM

```python
# 1. ä¸‹è½½å®Œæˆè§¦å‘å·¥ä½œæµ
download_task = await download_service.get_task(download_task_id)
media_file_path = download_task.file_path

# 2. é…ç½®å·¥ä½œæµ
config = STRMWorkflowConfig(
    upload_mode='copy',  # å¤åˆ¶æ¨¡å¼ï¼Œä¿ç•™æºæ–‡ä»¶åšç§
    cloud_storage='115',
    cloud_target_path='/ç”µå½±',
    scrape_on_cloud=False,  # ä¸åœ¨ç½‘ç›˜åˆ®å‰Š
    scrape_on_local=True,  # åœ¨æœ¬åœ°åˆ®å‰Š
    generate_strm=True,
    generate_nfo=True,
    media_servers=['plex', 'jellyfin'],  # é€šçŸ¥Plexå’ŒJellyfinåˆ·æ–°
    auto_refresh=True
)

# 3. å¯åŠ¨å·¥ä½œæµ
workflow_manager = STRMWorkflowManager(db)
task = await workflow_manager.process_download_complete(
    download_task_id, media_file_path, config
)
```

### ç¤ºä¾‹2ï¼šç§»åŠ¨æ¨¡å¼ï¼ˆä¸Šä¼ ååˆ é™¤æœ¬åœ°æ–‡ä»¶ï¼‰

```python
config = STRMWorkflowConfig(
    upload_mode='move',  # ç§»åŠ¨æ¨¡å¼ï¼Œä¸Šä¼ ååˆ é™¤æœ¬åœ°æ–‡ä»¶
    cloud_storage='115',
    cloud_target_path='/ç”µå½±',
    # ... å…¶ä»–é…ç½®
)
```

### ç¤ºä¾‹3ï¼šç½‘ç›˜å†…å¤åˆ¶/ç§»åŠ¨

```python
# ç½‘ç›˜å†…å¤åˆ¶æ–‡ä»¶
await cloud_storage_service.copy_file(
    cloud_storage='115',
    source_path='/ç”µå½±/xxx.mkv',
    target_path='/ç”µå½±/å¤‡ä»½/xxx.mkv',
    operation='copy'  # copy/move
)
```

## ğŸ‰ ç³»ç»Ÿä¼˜åŠ¿æ€»ç»“

### 1. å®Œæ•´å·¥ä½œæµ
- âœ… ä»ä¸‹è½½åˆ°STRMç”Ÿæˆçš„ç«¯åˆ°ç«¯è‡ªåŠ¨åŒ–
- âœ… æ”¯æŒå¤šç§è§¦å‘æ–¹å¼ï¼ˆä¸‹è½½å®Œæˆã€æ‰‹åŠ¨è§¦å‘ã€å®šæ—¶ä»»åŠ¡ï¼‰

### 2. æ™ºèƒ½æ–‡ä»¶ç®¡ç†
- âœ… æ”¯æŒå¤åˆ¶/ç§»åŠ¨æ¨¡å¼
- âœ… ä¿ç•™åšç§æˆ–æ¸…ç†ç©ºé—´
- âœ… è‡ªåŠ¨æ¸…ç†ç©ºæ–‡ä»¶å¤¹

### 3. å­—å¹•åŒæ­¥å¤„ç†
- âœ… è‡ªåŠ¨è¯†åˆ«å’Œä¸Šä¼ å­—å¹•æ–‡ä»¶
- âœ… é‡å‘½åå­—å¹•æ–‡ä»¶åŒ¹é…åª’ä½“æ–‡ä»¶
- âœ… ç”Ÿæˆå­—å¹•æ–‡ä»¶åˆ°STRMç›®å½•

### 4. å¤šåª’ä½“æœåŠ¡å™¨æ”¯æŒ
- âœ… Plexã€Jellyfinã€Embyå…¨æ”¯æŒ
- âœ… è‡ªåŠ¨åˆ·æ–°åª’ä½“åº“
- âœ… å¯é…ç½®åˆ·æ–°å»¶è¿Ÿ

### 5. çµæ´»é…ç½®
- âœ… å¯é€‰çš„ç½‘ç›˜åˆ®å‰Š
- âœ… å¯é€‰çš„STRMç”Ÿæˆ
- âœ… å¯é€‰çš„åª’ä½“åº“åˆ·æ–°
- âœ… å¯é€‰çš„è¦†ç›–æ¨¡å¼

### 6. å¢é‡æ›´æ–°
- âœ… æ–‡ä»¶æ ‘ç®¡ç†
- âœ… å¢é‡STRMç”Ÿæˆ
- âœ… ç”Ÿå‘½å‘¨æœŸè¿½è¸ª

### 7. åŸç”Ÿé›†æˆ
- âœ… ç³»ç»ŸåŸç”ŸåŠŸèƒ½ï¼Œéæ’ä»¶
- âœ… æ·±åº¦é›†æˆä¸‹è½½ã€ä¸Šä¼ ã€åª’ä½“ç®¡ç†
- âœ… ç»Ÿä¸€é…ç½®å’Œç®¡ç†

## ğŸ“‹ å®ç°ä¼˜å…ˆçº§

### é«˜ä¼˜å…ˆçº§ï¼ˆæ ¸å¿ƒåŠŸèƒ½ï¼‰
1. âœ… STRMæ–‡ä»¶ç”Ÿæˆå™¨ï¼ˆåŸºç¡€åŠŸèƒ½ï¼‰
2. âœ… æ–‡ä»¶ä¸Šä¼ ç®¡ç†å™¨ï¼ˆæ”¯æŒå¤åˆ¶/ç§»åŠ¨ï¼‰
3. âœ… å­—å¹•æ–‡ä»¶å¤„ç†å™¨
4. âœ… STRMå·¥ä½œæµç®¡ç†å™¨ï¼ˆå®Œæ•´æµç¨‹ï¼‰

### ä¸­ä¼˜å…ˆçº§ï¼ˆå¢å¼ºåŠŸèƒ½ï¼‰
5. âœ… åª’ä½“æœåŠ¡å™¨é€šçŸ¥å™¨ï¼ˆPlex/Jellyfin/Embyï¼‰
6. âœ… æ–‡ä»¶æ ‘ç®¡ç†å™¨ï¼ˆå¢é‡æ›´æ–°ï¼‰
7. âœ… è¦†ç›–æ¨¡å¼æ§åˆ¶
8. âœ… ç”Ÿå‘½å‘¨æœŸè¿½è¸ª

### ä½ä¼˜å…ˆçº§ï¼ˆé«˜çº§åŠŸèƒ½ï¼‰
9. âœ… ç½‘ç›˜åˆ®å‰ŠåŠŸèƒ½
10. âœ… æœ¬åœ°åˆ®å‰Šä¼˜åŒ–
11. âœ… ç½‘ç›˜å†…å¤åˆ¶/ç§»åŠ¨æ“ä½œ

